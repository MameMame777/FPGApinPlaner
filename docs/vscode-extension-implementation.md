# FPGA Pin Planner - VSCodeÊã°ÂºµÊ©üËÉΩÂÆüË£Ö„Ç¨„Ç§„Éâ

## üéØ **Ê¶ÇË¶Å**

ÁèæÂú®„ÅÆWeb„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíVSCodeÊã°ÂºµÊ©üËÉΩ„Å®„Åó„Å¶ÂÆüË£Ö„Åô„Çã„Åü„ÇÅ„ÅÆÂåÖÊã¨ÁöÑ„Å™„Ç¨„Ç§„Éâ„Åß„Åô„ÄÇÊó¢Â≠ò„ÅÆReact + TypeScript + Konva.js„Ç≥„Éº„Éâ„Éô„Éº„Çπ„ÇíÊúÄÂ§ßÈôêÊ¥ªÁî®„Åó„Å™„Åå„Çâ„ÄÅVSCodeÁí∞Â¢É„Å´Áµ±Âêà„Åó„Åæ„Åô„ÄÇ

## üìã **ÂÆüË£ÖË®àÁîª**

### **Phase 1: Âü∫Êú¨ÊßãÈÄ†„ÅÆÂÆüË£Ö (Week 1-2)**

- VSCodeÊã°ÂºµÊ©üËÉΩ„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊßãÈÄ†‰ΩúÊàê
- Webview „Éë„Éç„É´„ÅÆÂü∫Êú¨ÂÆüË£Ö
- ÁèæÂú®„ÅÆReact„Ç¢„Éó„É™„ÅÆÁµ±Âêà

### **Phase 2: VSCode APIÁµ±Âêà (Week 3-4)**

- „Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†„Ç¢„ÇØ„Çª„Çπ
- Ë®≠ÂÆöÁÆ°ÁêÜ„ÅÆÁµ±Âêà
- „Ç≥„Éû„É≥„Éâ„Å®„Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà

### **Phase 3: È´òÂ∫¶„Å™Áµ±Âêà (Week 5-6)**

- „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éï„Ç°„Ç§„É´ÈÄ£Êê∫
- GitÁµ±Âêà
- ‰ªñ„ÅÆÊã°ÂºµÊ©üËÉΩ„Å®„ÅÆÈÄ£Êê∫

## üèóÔ∏è **„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊßãÈÄ†**

```
fpga-pin-planner-vscode/
‚îú‚îÄ‚îÄ package.json              # Êã°ÂºµÊ©üËÉΩ„ÅÆ„É°„Çø„Éá„Éº„Çø
‚îú‚îÄ‚îÄ tsconfig.json             # TypeScriptË®≠ÂÆö
‚îú‚îÄ‚îÄ webpack.config.js         # „Éê„É≥„Éâ„É´Ë®≠ÂÆö
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ extension.ts          # „É°„Ç§„É≥„Ç®„É≥„Éà„É™„Éº„Éù„Ç§„É≥„Éà
‚îÇ   ‚îú‚îÄ‚îÄ panels/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ FPGAPinPlannerPanel.ts
‚îÇ   ‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ openPinPlanner.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exportXDC.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ saveProject.ts
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FileService.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProjectService.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SettingsService.ts
‚îÇ   ‚îî‚îÄ‚îÄ webview/
‚îÇ       ‚îú‚îÄ‚îÄ index.html
‚îÇ       ‚îî‚îÄ‚îÄ dist/             # React „Ç¢„Éó„É™„ÅÆ„Éì„É´„ÉâÁµêÊûú
‚îú‚îÄ‚îÄ media/
‚îÇ   ‚îú‚îÄ‚îÄ icons/
‚îÇ   ‚îî‚îÄ‚îÄ screenshots/
‚îú‚îÄ‚îÄ syntaxes/                 # XDC „Ç∑„É≥„Çø„ÉÉ„ÇØ„Çπ„Éè„Ç§„É©„Ç§„Éà
‚îÇ   ‚îî‚îÄ‚îÄ xdc.tmLanguage.json
‚îî‚îÄ‚îÄ README.md
```

## üìù **package.json Ë®≠ÂÆö**

```json
{
  "name": "fpga-pin-planner",
  "displayName": "FPGA Pin Planner",
  "description": "Interactive FPGA pin planning and constraint generation tool",
  "version": "1.0.0",
  "publisher": "your-publisher-name",
  "engines": {
    "vscode": "^1.74.0"
  },
  "categories": [
    "Other",
    "Snippets",
    "Language Packs"
  ],
  "keywords": [
    "fpga",
    "xilinx",
    "vivado",
    "pin planning",
    "xdc",
    "constraints"
  ],
  "activationEvents": [
    "onCommand:fpgaPinPlanner.open",
    "onLanguage:xdc",
    "workspaceContains:**/*.csv"
  ],
  "main": "./dist/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "fpgaPinPlanner.open",
        "title": "Open FPGA Pin Planner",
        "category": "FPGA",
        "icon": "$(circuit-board)"
      },
      {
        "command": "fpgaPinPlanner.importCSV",
        "title": "Import Pin CSV",
        "category": "FPGA"
      },
      {
        "command": "fpgaPinPlanner.exportXDC",
        "title": "Export XDC Constraints",
        "category": "FPGA"
      },
      {
        "command": "fpgaPinPlanner.saveProject",
        "title": "Save Pin Planning Project",
        "category": "FPGA"
      }
    ],
    "keybindings": [
      {
        "command": "fpgaPinPlanner.open",
        "key": "ctrl+shift+p",
        "mac": "cmd+shift+p",
        "when": "!terminalFocus"
      },
      {
        "command": "fpgaPinPlanner.exportXDC",
        "key": "ctrl+shift+e",
        "mac": "cmd+shift+e",
        "when": "fpgaPinPlannerActive"
      }
    ],
    "menus": {
      "explorer/context": [
        {
          "when": "resourceExtname == .csv",
          "command": "fpgaPinPlanner.importCSV",
          "group": "fpga"
        }
      ],
      "editor/title": [
        {
          "when": "resourceExtname == .xdc",
          "command": "fpgaPinPlanner.open",
          "group": "navigation"
        }
      ]
    },
    "configuration": {
      "type": "object",
      "title": "FPGA Pin Planner",
      "properties": {
        "fpgaPinPlanner.defaultZoom": {
          "type": "number",
          "default": 1.0,
          "description": "Default zoom level for pin planner"
        },
        "fpgaPinPlanner.showGrid": {
          "type": "boolean",
          "default": true,
          "description": "Show grid lines in pin planner"
        },
        "fpgaPinPlanner.autoSave": {
          "type": "boolean",
          "default": true,
          "description": "Automatically save changes"
        },
        "fpgaPinPlanner.exportPath": {
          "type": "string",
          "default": "./constraints",
          "description": "Default path for exported files"
        }
      }
    },
    "languages": [
      {
        "id": "xdc",
        "aliases": ["Xilinx Design Constraints", "xdc"],
        "extensions": [".xdc"],
        "configuration": "./language-configuration.json"
      }
    ],
    "grammars": [
      {
        "language": "xdc",
        "scopeName": "source.xdc",
        "path": "./syntaxes/xdc.tmLanguage.json"
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "webpack --mode production",
    "watch": "webpack --mode development --watch",
    "pretest": "npm run compile && npm run lint",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js"
  },
  "devDependencies": {
    "@types/vscode": "^1.74.0",
    "@types/node": "16.x",
    "@typescript-eslint/eslint-plugin": "^5.45.0",
    "@typescript-eslint/parser": "^5.45.0",
    "eslint": "^8.28.0",
    "typescript": "^4.9.4",
    "webpack": "^5.75.0",
    "webpack-cli": "^5.0.1",
    "ts-loader": "^9.4.1"
  },
  "dependencies": {
    "vscode": "^1.1.37"
  }
}
```

## üöÄ **„Ç≥„Ç¢ÂÆüË£Ö**

### **1. „É°„Ç§„É≥„Ç®„ÇØ„Çπ„ÉÜ„É≥„Ç∑„Éß„É≥ (extension.ts)**

```typescript
import * as vscode from 'vscode';
import { FPGAPinPlannerPanel } from './panels/FPGAPinPlannerPanel';
import { FileService } from './services/FileService';
import { ProjectService } from './services/ProjectService';

let pinPlannerPanel: FPGAPinPlannerPanel | undefined;

export function activate(context: vscode.ExtensionContext) {
  console.log('FPGA Pin Planner extension activated');

  // „Ç≥„Éû„É≥„ÉâÁôªÈå≤
  registerCommands(context);
  
  // „Éï„Ç°„Ç§„É´„Ç¶„Ç©„ÉÉ„ÉÅ„É£„ÉºË®≠ÂÆö
  setupFileWatchers(context);
  
  // Ë®ÄË™û„Çµ„Éù„Éº„Éà
  setupLanguageSupport(context);
}

function registerCommands(context: vscode.ExtensionContext) {
  // „É°„Ç§„É≥„Éë„Éç„É´„ÇíÈñã„Åè
  const openCommand = vscode.commands.registerCommand(
    'fpgaPinPlanner.open',
    () => {
      if (pinPlannerPanel) {
        pinPlannerPanel.reveal();
      } else {
        pinPlannerPanel = new FPGAPinPlannerPanel(context.extensionUri);
        
        pinPlannerPanel.onDidDispose(() => {
          pinPlannerPanel = undefined;
        });
      }
    }
  );

  // CSV „Ç§„É≥„Éù„Éº„Éà
  const importCSVCommand = vscode.commands.registerCommand(
    'fpgaPinPlanner.importCSV',
    async (uri: vscode.Uri) => {
      try {
        const csvContent = await FileService.readFile(uri);
        if (pinPlannerPanel) {
          pinPlannerPanel.importCSV(csvContent);
        } else {
          // „Éë„Éç„É´„ÇíÈñã„ÅÑ„Å¶„Åã„Çâ„Ç§„É≥„Éù„Éº„Éà
          vscode.commands.executeCommand('fpgaPinPlanner.open');
          setTimeout(() => {
            pinPlannerPanel?.importCSV(csvContent);
          }, 1000);
        }
      } catch (error) {
        vscode.window.showErrorMessage(`CSV import failed: ${error}`);
      }
    }
  );

  // XDC „Ç®„ÇØ„Çπ„Éù„Éº„Éà
  const exportXDCCommand = vscode.commands.registerCommand(
    'fpgaPinPlanner.exportXDC',
    async () => {
      if (!pinPlannerPanel) {
        vscode.window.showWarningMessage('Please open FPGA Pin Planner first');
        return;
      }

      try {
        const xdcContent = await pinPlannerPanel.generateXDC();
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        
        if (workspaceFolder) {
          const exportPath = vscode.workspace.getConfiguration('fpgaPinPlanner').get<string>('exportPath', './constraints');
          const filePath = vscode.Uri.joinPath(workspaceFolder.uri, exportPath, 'pins.xdc');
          
          await FileService.writeFile(filePath, xdcContent);
          vscode.window.showInformationMessage(`XDC exported to ${filePath.fsPath}`);
          
          // „Éï„Ç°„Ç§„É´„ÇíÈñã„Åè
          const document = await vscode.workspace.openTextDocument(filePath);
          vscode.window.showTextDocument(document);
        }
      } catch (error) {
        vscode.window.showErrorMessage(`XDC export failed: ${error}`);
      }
    }
  );

  // „Éó„É≠„Ç∏„Çß„ÇØ„Éà‰øùÂ≠ò
  const saveProjectCommand = vscode.commands.registerCommand(
    'fpgaPinPlanner.saveProject',
    async () => {
      if (!pinPlannerPanel) {
        vscode.window.showWarningMessage('Please open FPGA Pin Planner first');
        return;
      }

      try {
        const projectData = await pinPlannerPanel.getProjectData();
        await ProjectService.saveProject(projectData);
        vscode.window.showInformationMessage('Project saved successfully');
      } catch (error) {
        vscode.window.showErrorMessage(`Project save failed: ${error}`);
      }
    }
  );

  context.subscriptions.push(
    openCommand,
    importCSVCommand,
    exportXDCCommand,
    saveProjectCommand
  );
}

function setupFileWatchers(context: vscode.ExtensionContext) {
  // CSV „Éï„Ç°„Ç§„É´„ÅÆÂ§âÊõ¥„ÇíÁõ£Ë¶ñ
  const csvWatcher = vscode.workspace.createFileSystemWatcher('**/*.csv');
  
  csvWatcher.onDidChange(async (uri) => {
    if (pinPlannerPanel) {
      const shouldReload = await vscode.window.showInformationMessage(
        'CSV file changed. Reload pin data?',
        'Yes',
        'No'
      );
      
      if (shouldReload === 'Yes') {
        const csvContent = await FileService.readFile(uri);
        pinPlannerPanel.importCSV(csvContent);
      }
    }
  });

  context.subscriptions.push(csvWatcher);
}

function setupLanguageSupport(context: vscode.ExtensionContext) {
  // XDC „Éï„Ç°„Ç§„É´„ÅÆ„Ç≥„Éº„ÉâË£úÂÆå
  const xdcCompletionProvider = vscode.languages.registerCompletionItemProvider(
    'xdc',
    {
      provideCompletionItems(document, position) {
        const completions: vscode.CompletionItem[] = [];
        
        // Âü∫Êú¨ÁöÑ„Å™ XDC „Ç≥„Éû„É≥„Éâ„ÅÆË£úÂÆå
        const xdcCommands = [
          'set_property',
          'create_clock',
          'set_input_delay',
          'set_output_delay',
          'set_false_path'
        ];
        
        xdcCommands.forEach(cmd => {
          const completion = new vscode.CompletionItem(cmd, vscode.CompletionItemKind.Keyword);
          completion.detail = `XDC command: ${cmd}`;
          completions.push(completion);
        });
        
        return completions;
      }
    }
  );

  context.subscriptions.push(xdcCompletionProvider);
}

export function deactivate() {
  if (pinPlannerPanel) {
    pinPlannerPanel.dispose();
  }
}
```

### **2. Webview „Éë„Éç„É´ (FPGAPinPlannerPanel.ts)**

```typescript
import * as vscode from 'vscode';
import { FileService } from '../services/FileService';

export class FPGAPinPlannerPanel {
  public static readonly viewType = 'fpgaPinPlanner';
  private readonly _panel: vscode.WebviewPanel;
  private readonly _extensionUri: vscode.Uri;
  private _disposables: vscode.Disposable[] = [];

  constructor(extensionUri: vscode.Uri) {
    this._extensionUri = extensionUri;

    this._panel = vscode.window.createWebviewPanel(
      FPGAPinPlannerPanel.viewType,
      'FPGA Pin Planner',
      vscode.ViewColumn.One,
      {
        enableScripts: true,
        localResourceRoots: [
          vscode.Uri.joinPath(extensionUri, 'dist'),
          vscode.Uri.joinPath(extensionUri, 'webview')
        ],
        retainContextWhenHidden: true
      }
    );

    this._panel.webview.html = this.getHtmlForWebview();
    this.setupMessageHandling();
  }

  private getHtmlForWebview(): string {
    const webview = this._panel.webview;
    
    // React „Ç¢„Éó„É™„ÅÆ„É™„ÇΩ„Éº„Çπ„ÇíÂèÇÁÖß
    const scriptUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'webview', 'dist', 'bundle.js')
    );
    const styleUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'webview', 'dist', 'bundle.css')
    );

    // CSP (Content Security Policy) „ÇíË®≠ÂÆö
    const nonce = this.getNonce();

    return `<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="Content-Security-Policy" content="default-src 'none'; 
        style-src ${webview.cspSource} 'unsafe-inline'; 
        script-src 'nonce-${nonce}'; 
        connect-src ${webview.cspSource};">
      <link href="${styleUri}" rel="stylesheet">
      <title>FPGA Pin Planner</title>
    </head>
    <body>
      <div id="root"></div>
      <script nonce="${nonce}" src="${scriptUri}"></script>
      <script nonce="${nonce}">
        // VSCode API „Çí React „Ç¢„Éó„É™„Å´Ê∏°„Åô
        window.vscode = acquireVsCodeApi();
        
        // ÂàùÊúüË®≠ÂÆö„ÇíÊ∏°„Åô
        window.vscodeConfig = {
          theme: document.body.classList.contains('vscode-dark') ? 'dark' : 'light',
          workspaceFolder: '${vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || ''}',
          settings: {
            defaultZoom: ${vscode.workspace.getConfiguration('fpgaPinPlanner').get('defaultZoom', 1.0)},
            showGrid: ${vscode.workspace.getConfiguration('fpgaPinPlanner').get('showGrid', true)},
            autoSave: ${vscode.workspace.getConfiguration('fpgaPinPlanner').get('autoSave', true)}
          }
        };
      </script>
    </body>
    </html>`;
  }

  private setupMessageHandling() {
    this._panel.webview.onDidReceiveMessage(
      async (message) => {
        switch (message.type) {
          case 'openFile':
            await this.handleOpenFile();
            break;
          case 'saveProject':
            await this.handleSaveProject(message.data);
            break;
          case 'exportXDC':
            await this.handleExportXDC(message.data);
            break;
          case 'showMessage':
            vscode.window.showInformationMessage(message.message);
            break;
          case 'showError':
            vscode.window.showErrorMessage(message.message);
            break;
          case 'updateSettings':
            await this.handleUpdateSettings(message.settings);
            break;
        }
      },
      null,
      this._disposables
    );
  }

  private async handleOpenFile() {
    const options: vscode.OpenDialogOptions = {
      canSelectMany: false,
      openLabel: 'Open CSV File',
      filters: {
        'CSV files': ['csv'],
        'All files': ['*']
      }
    };

    const fileUri = await vscode.window.showOpenDialog(options);
    if (fileUri && fileUri[0]) {
      const content = await FileService.readFile(fileUri[0]);
      this._panel.webview.postMessage({
        type: 'csvLoaded',
        content: content,
        fileName: fileUri[0].fsPath
      });
    }
  }

  private async handleSaveProject(projectData: any) {
    const options: vscode.SaveDialogOptions = {
      saveLabel: 'Save Project',
      filters: {
        'JSON files': ['json'],
        'All files': ['*']
      }
    };

    const fileUri = await vscode.window.showSaveDialog(options);
    if (fileUri) {
      await FileService.writeFile(fileUri, JSON.stringify(projectData, null, 2));
      vscode.window.showInformationMessage('Project saved successfully');
    }
  }

  private async handleExportXDC(xdcData: string) {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      vscode.window.showErrorMessage('No workspace folder found');
      return;
    }

    const exportPath = vscode.workspace.getConfiguration('fpgaPinPlanner').get<string>('exportPath', './constraints');
    const filePath = vscode.Uri.joinPath(workspaceFolder.uri, exportPath, 'pins.xdc');
    
    await FileService.writeFile(filePath, xdcData);
    vscode.window.showInformationMessage(`XDC exported to ${filePath.fsPath}`);
    
    // „Éï„Ç°„Ç§„É´„ÇíÈñã„Åè
    const document = await vscode.workspace.openTextDocument(filePath);
    vscode.window.showTextDocument(document);
  }

  private async handleUpdateSettings(settings: any) {
    const config = vscode.workspace.getConfiguration('fpgaPinPlanner');
    for (const [key, value] of Object.entries(settings)) {
      await config.update(key, value, vscode.ConfigurationTarget.Workspace);
    }
  }

  public importCSV(content: string) {
    this._panel.webview.postMessage({
      type: 'importCSV',
      content: content
    });
  }

  public async generateXDC(): Promise<string> {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('XDC generation timeout'));
      }, 5000);

      const messageHandler = this._panel.webview.onDidReceiveMessage((message) => {
        if (message.type === 'xdcGenerated') {
          clearTimeout(timeout);
          messageHandler.dispose();
          resolve(message.content);
        }
      });

      this._panel.webview.postMessage({ type: 'generateXDC' });
    });
  }

  public async getProjectData(): Promise<any> {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Get project data timeout'));
      }, 5000);

      const messageHandler = this._panel.webview.onDidReceiveMessage((message) => {
        if (message.type === 'projectData') {
          clearTimeout(timeout);
          messageHandler.dispose();
          resolve(message.data);
        }
      });

      this._panel.webview.postMessage({ type: 'getProjectData' });
    });
  }

  public reveal() {
    this._panel.reveal();
  }

  public dispose() {
    this._panel.dispose();
    while (this._disposables.length) {
      const disposable = this._disposables.pop();
      if (disposable) {
        disposable.dispose();
      }
    }
  }

  public onDidDispose(callback: () => void) {
    this._panel.onDidDispose(callback);
  }

  private getNonce(): string {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  }
}
```

### **3. „Éï„Ç°„Ç§„É´„Çµ„Éº„Éì„Çπ (FileService.ts)**

```typescript
import * as vscode from 'vscode';
import * as path from 'path';

export class FileService {
  /**
   * „Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„ÇÄ
   */
  static async readFile(uri: vscode.Uri): Promise<string> {
    try {
      const fileContent = await vscode.workspace.fs.readFile(uri);
      return Buffer.from(fileContent).toString('utf8');
    } catch (error) {
      throw new Error(`Failed to read file ${uri.fsPath}: ${error}`);
    }
  }

  /**
   * „Éï„Ç°„Ç§„É´„Å´Êõ∏„ÅçËæº„ÇÄ
   */
  static async writeFile(uri: vscode.Uri, content: string): Promise<void> {
    try {
      // „Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàê
      const dirname = path.dirname(uri.fsPath);
      const dirUri = vscode.Uri.file(dirname);
      
      try {
        await vscode.workspace.fs.stat(dirUri);
      } catch {
        await vscode.workspace.fs.createDirectory(dirUri);
      }

      const encoder = new TextEncoder();
      await vscode.workspace.fs.writeFile(uri, encoder.encode(content));
    } catch (error) {
      throw new Error(`Failed to write file ${uri.fsPath}: ${error}`);
    }
  }

  /**
   * „Éï„Ç°„Ç§„É´„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
   */
  static async fileExists(uri: vscode.Uri): Promise<boolean> {
    try {
      await vscode.workspace.fs.stat(uri);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * „ÉØ„Éº„ÇØ„Çπ„Éö„Éº„ÇπÂÜÖ„ÅÆÈñ¢ÈÄ£„Éï„Ç°„Ç§„É´„ÇíÊ§úÁ¥¢
   */
  static async findRelatedFiles(extensions: string[]): Promise<vscode.Uri[]> {
    const files: vscode.Uri[] = [];
    
    for (const extension of extensions) {
      const pattern = `**/*.${extension}`;
      const foundFiles = await vscode.workspace.findFiles(pattern);
      files.push(...foundFiles);
    }
    
    return files;
  }

  /**
   * XDC „Éï„Ç°„Ç§„É´„ÅÆ„Éë„ÇπÂÄôË£ú„ÇíÂèñÂæó
   */
  static async getXDCFilePaths(): Promise<vscode.Uri[]> {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      return [];
    }

    const commonPaths = [
      'constraints',
      'src/constraints',
      'hdl/constraints',
      'vivado/constraints'
    ];

    const paths: vscode.Uri[] = [];
    for (const commonPath of commonPaths) {
      const uri = vscode.Uri.joinPath(workspaceFolder.uri, commonPath);
      if (await this.fileExists(uri)) {
        paths.push(uri);
      }
    }

    return paths;
  }
}
```

### **4. „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Çµ„Éº„Éì„Çπ (ProjectService.ts)**

```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import { FileService } from './FileService';

export interface FPGAProject {
  name: string;
  version: string;
  created: Date;
  modified: Date;
  pins: any[];
  settings: any;
  packageInfo: any;
}

export class ProjectService {
  private static readonly PROJECT_EXTENSION = '.fpgaproj';

  /**
   * „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Çí‰øùÂ≠ò
   */
  static async saveProject(projectData: Partial<FPGAProject>): Promise<void> {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      throw new Error('No workspace folder found');
    }

    const project: FPGAProject = {
      name: projectData.name || path.basename(workspaceFolder.uri.fsPath),
      version: '1.0.0',
      created: projectData.created || new Date(),
      modified: new Date(),
      pins: projectData.pins || [],
      settings: projectData.settings || {},
      packageInfo: projectData.packageInfo || {}
    };

    const projectPath = vscode.Uri.joinPath(
      workspaceFolder.uri,
      `${project.name}${this.PROJECT_EXTENSION}`
    );

    await FileService.writeFile(projectPath, JSON.stringify(project, null, 2));
  }

  /**
   * „Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíË™≠„ÅøËæº„Åø
   */
  static async loadProject(uri?: vscode.Uri): Promise<FPGAProject | null> {
    let projectUri = uri;
    
    if (!projectUri) {
      // „ÉØ„Éº„ÇØ„Çπ„Éö„Éº„ÇπÂÜÖ„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éï„Ç°„Ç§„É´„ÇíÊ§úÁ¥¢
      const projectFiles = await vscode.workspace.findFiles(`**/*${this.PROJECT_EXTENSION}`);
      if (projectFiles.length === 0) {
        return null;
      }
      
      if (projectFiles.length === 1) {
        projectUri = projectFiles[0];
      } else {
        // Ë§áÊï∞„ÅÇ„ÇãÂ†¥Âêà„ÅØ„É¶„Éº„Ç∂„Éº„Å´ÈÅ∏Êäû„Åï„Åõ„Çã
        const selected = await vscode.window.showQuickPick(
          projectFiles.map(file => ({
            label: path.basename(file.fsPath),
            description: file.fsPath,
            uri: file
          })),
          { placeHolder: 'Select project file' }
        );
        
        if (!selected) {
          return null;
        }
        projectUri = selected.uri;
      }
    }

    try {
      const content = await FileService.readFile(projectUri);
      const project: FPGAProject = JSON.parse(content);
      return project;
    } catch (error) {
      throw new Error(`Failed to load project: ${error}`);
    }
  }

  /**
   * ÊúÄËøë„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà‰∏ÄË¶ß„ÇíÂèñÂæó
   */
  static async getRecentProjects(): Promise<vscode.Uri[]> {
    const projectFiles = await vscode.workspace.findFiles(`**/*${this.PROJECT_EXTENSION}`);
    
    // ÊúÄÁµÇÊõ¥Êñ∞Êó•ÊôÇ„Åß„ÇΩ„Éº„Éà
    const projectsWithStats = await Promise.all(
      projectFiles.map(async (uri) => {
        const stat = await vscode.workspace.fs.stat(uri);
        return { uri, mtime: stat.mtime };
      })
    );

    projectsWithStats.sort((a, b) => b.mtime - a.mtime);
    return projectsWithStats.map(p => p.uri);
  }

  /**
   * „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Çí„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÔºà‰ªñ„ÅÆÂΩ¢ÂºèÔºâ
   */
  static async exportProject(project: FPGAProject, format: 'json' | 'xml' | 'csv'): Promise<string> {
    switch (format) {
      case 'json':
        return JSON.stringify(project, null, 2);
      
      case 'xml':
        return this.generateXMLExport(project);
      
      case 'csv':
        return this.generateCSVExport(project);
      
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  }

  private static generateXMLExport(project: FPGAProject): string {
    return `<?xml version="1.0" encoding="UTF-8"?>
<FPGAProject name="${project.name}" version="${project.version}">
  <Info>
    <Created>${project.created.toISOString()}</Created>
    <Modified>${project.modified.toISOString()}</Modified>
  </Info>
  <Pins>
    ${project.pins.map(pin => `
    <Pin id="${pin.id}" number="${pin.pinNumber}">
      <Position x="${pin.position.x}" y="${pin.position.y}" />
      <Signal>${pin.signalName || ''}</Signal>
      <Type>${pin.pinType}</Type>
      <Bank>${pin.bank}</Bank>
    </Pin>`).join('')}
  </Pins>
</FPGAProject>`;
  }

  private static generateCSVExport(project: FPGAProject): string {
    const headers = ['Pin Number', 'Signal Name', 'Pin Type', 'Bank', 'Position X', 'Position Y'];
    const rows = project.pins.map(pin => [
      pin.pinNumber,
      pin.signalName || '',
      pin.pinType,
      pin.bank,
      pin.position.x.toString(),
      pin.position.y.toString()
    ]);

    return [headers.join(','), ...rows.map(row => row.join(','))].join('\n');
  }
}
```

## üîß **WebviewÁµ±Âêà**

### **React „Ç¢„Éó„É™„ÅÆ‰øÆÊ≠£**

ÁèæÂú®„ÅÆReact„Ç¢„Éó„É™„Å´VSCodeÁµ±Âêà„ÅÆ„Åü„ÇÅ„ÅÆ„Ç≥„Éº„Éâ„ÇíËøΩÂä†„Åó„Åæ„ÅôÔºö

```typescript
// src/hooks/useVSCodeAPI.ts
import { useEffect, useCallback } from 'react';

declare global {
  interface Window {
    vscode?: {
      postMessage(message: any): void;
      getState(): any;
      setState(state: any): void;
    };
    vscodeConfig?: {
      theme: 'dark' | 'light';
      workspaceFolder: string;
      settings: {
        defaultZoom: number;
        showGrid: boolean;
        autoSave: boolean;
      };
    };
  }
}

export const useVSCodeAPI = () => {
  const isVSCode = typeof window !== 'undefined' && window.vscode;

  const postMessage = useCallback((message: any) => {
    if (isVSCode) {
      window.vscode!.postMessage(message);
    } else {
      console.log('VSCode message:', message);
    }
  }, [isVSCode]);

  const showMessage = useCallback((message: string, type: 'info' | 'error' = 'info') => {
    postMessage({
      type: type === 'info' ? 'showMessage' : 'showError',
      message
    });
  }, [postMessage]);

  const openFile = useCallback(() => {
    postMessage({ type: 'openFile' });
  }, [postMessage]);

  const saveProject = useCallback((projectData: any) => {
    postMessage({
      type: 'saveProject',
      data: projectData
    });
  }, [postMessage]);

  const exportXDC = useCallback((xdcContent: string) => {
    postMessage({
      type: 'exportXDC',
      data: xdcContent
    });
  }, [postMessage]);

  const updateSettings = useCallback((settings: any) => {
    postMessage({
      type: 'updateSettings',
      settings
    });
  }, [postMessage]);

  useEffect(() => {
    if (!isVSCode) return;

    const handleMessage = (event: MessageEvent) => {
      const message = event.data;
      
      switch (message.type) {
        case 'csvLoaded':
          // CSVË™≠„ÅøËæº„ÅøÂÆå‰∫Ü„ÅÆÂá¶ÁêÜ
          break;
        case 'importCSV':
          // CSV „Ç§„É≥„Éù„Éº„Éà„ÅÆÂá¶ÁêÜ
          break;
        case 'generateXDC':
          // XDC ÁîüÊàêË¶ÅÊ±Ç„ÅÆÂá¶ÁêÜ
          break;
        case 'getProjectData':
          // „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éá„Éº„ÇøÂèñÂæóË¶ÅÊ±Ç„ÅÆÂá¶ÁêÜ
          break;
      }
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, [isVSCode]);

  return {
    isVSCode,
    config: window.vscodeConfig,
    postMessage,
    showMessage,
    openFile,
    saveProject,
    exportXDC,
    updateSettings
  };
};
```

### **„É°„Ç§„É≥„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ‰øÆÊ≠£**

```typescript
// src/components/VSCodeApp.tsx
import React, { useEffect } from 'react';
import { useVSCodeAPI } from '../hooks/useVSCodeAPI';
import { useAppStore } from '../stores/app-store';
import { App } from './App';

export const VSCodeApp: React.FC = () => {
  const vscode = useVSCodeAPI();
  const { setPins, pins } = useAppStore();

  useEffect(() => {
    if (vscode.isVSCode && vscode.config) {
      // VSCodeË®≠ÂÆö„ÇíÈÅ©Áî®
      document.body.className = vscode.config.theme === 'dark' ? 'dark-theme' : 'light-theme';
    }
  }, [vscode.isVSCode, vscode.config]);

  // VSCode „É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É™„É≥„Ç∞
  useEffect(() => {
    if (!vscode.isVSCode) return;

    const handleMessage = (event: MessageEvent) => {
      const message = event.data;
      
      switch (message.type) {
        case 'csvLoaded':
          // CSVË™≠„ÅøËæº„ÅøÂÆå‰∫Ü
          vscode.showMessage(`CSV loaded: ${message.fileName}`);
          break;
          
        case 'importCSV':
          // CSV „Ç§„É≥„Éù„Éº„ÉàÂá¶ÁêÜ
          // „Åì„Åì„Åß CSV „Éë„Éº„Çπ„Å®„Éî„É≥Ë®≠ÂÆö„ÇíË°å„ÅÜ
          break;
          
        case 'generateXDC':
          // XDC ÁîüÊàêË¶ÅÊ±Ç
          const xdcContent = generateXDCFromPins(pins);
          vscode.postMessage({
            type: 'xdcGenerated',
            content: xdcContent
          });
          break;
          
        case 'getProjectData':
          // „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éá„Éº„ÇøÂèñÂæó
          const projectData = {
            name: 'Current Project',
            pins: pins,
            settings: vscode.config?.settings || {}
          };
          vscode.postMessage({
            type: 'projectData',
            data: projectData
          });
          break;
      }
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, [vscode, pins]);

  return (
    <div className="vscode-app">
      {vscode.isVSCode && (
        <div className="vscode-toolbar">
          <button onClick={vscode.openFile} className="vscode-button">
            üìÅ Open CSV
          </button>
          <button onClick={() => vscode.saveProject({})} className="vscode-button">
            üíæ Save Project
          </button>
          <button onClick={() => vscode.exportXDC('')} className="vscode-button">
            üìÑ Export XDC
          </button>
        </div>
      )}
      <App />
    </div>
  );
};

// XDCÁîüÊàê„Éò„É´„Éë„ÉºÈñ¢Êï∞
function generateXDCFromPins(pins: any[]): string {
  const assignedPins = pins.filter(pin => pin.signalName);
  
  const constraints = assignedPins.map(pin => {
    const lines = [];
    
    // „Éî„É≥ÈÖçÁΩÆÂà∂Á¥Ñ
    lines.push(`set_property PACKAGE_PIN ${pin.pinNumber} [get_ports ${pin.signalName}]`);
    
    // I/OÊ®ôÊ∫ñË®≠ÂÆö
    if (pin.voltage) {
      const iostandard = pin.voltage === '3.3V' ? 'LVCMOS33' : 
                        pin.voltage === '1.8V' ? 'LVCMOS18' :
                        pin.voltage === '2.5V' ? 'LVCMOS25' : 'LVCMOS33';
      lines.push(`set_property IOSTANDARD ${iostandard} [get_ports ${pin.signalName}]`);
    }
    
    return lines.join('\n');
  }).join('\n\n');
  
  const header = `# FPGA Pin Planner Generated Constraints
# Generated on ${new Date().toISOString()}
# Total pins assigned: ${assignedPins.length}

`;
  
  return header + constraints;
}
```

## üì¶ **„Éì„É´„Éâ„Å®„Éá„Éó„É≠„Ç§**

### **WebpackË®≠ÂÆö**

```javascript
// webpack.config.js
const path = require('path');

module.exports = [
  // Êã°ÂºµÊ©üËÉΩÊú¨‰Ωì„ÅÆ„Éì„É´„Éâ
  {
    target: 'node',
    mode: 'none',
    entry: './src/extension.ts',
    output: {
      path: path.resolve(__dirname, 'dist'),
      filename: 'extension.js',
      libraryTarget: 'commonjs2'
    },
    resolve: {
      extensions: ['.ts', '.js']
    },
    module: {
      rules: [
        {
          test: /\.ts$/,
          exclude: /node_modules/,
          use: 'ts-loader'
        }
      ]
    },
    externals: {
      vscode: 'commonjs vscode'
    }
  },
  // Webview (React „Ç¢„Éó„É™) „ÅÆ„Éì„É´„Éâ
  {
    target: 'web',
    mode: 'production',
    entry: './src/webview/index.tsx',
    output: {
      path: path.resolve(__dirname, 'webview/dist'),
      filename: 'bundle.js'
    },
    resolve: {
      extensions: ['.tsx', '.ts', '.js']
    },
    module: {
      rules: [
        {
          test: /\.tsx?$/,
          use: 'ts-loader',
          exclude: /node_modules/
        },
        {
          test: /\.css$/,
          use: ['style-loader', 'css-loader']
        }
      ]
    }
  }
];
```

### **XDCË®ÄË™û„Çµ„Éù„Éº„Éà**

```json
// syntaxes/xdc.tmLanguage.json
{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "XDC",
  "patterns": [
    {
      "include": "#keywords"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#comments"
    }
  ],
  "repository": {
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.xdc",
          "match": "\\b(set_property|create_clock|set_input_delay|set_output_delay|set_false_path|set_max_delay|set_min_delay|get_ports|get_clocks|get_cells)\\b"
        }
      ]
    },
    "strings": {
      "name": "string.quoted.double.xdc",
      "begin": "\"",
      "end": "\"",
      "patterns": [
        {
          "name": "constant.character.escape.xdc",
          "match": "\\\\."
        }
      ]
    },
    "comments": {
      "patterns": [
        {
          "name": "comment.line.number-sign.xdc",
          "match": "#.*$"
        }
      ]
    }
  },
  "scopeName": "source.xdc"
}
```

### **ÂÖ¨ÈñãÊ∫ñÂÇô**

```bash
# ÂøÖË¶Å„Å™„ÉÑ„Éº„É´„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´
npm install -g vsce

# „Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆ„Éì„É´„Éâ
npm run vscode:prepublish

# Êã°ÂºµÊ©üËÉΩ„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆ‰ΩúÊàê
vsce package

# Marketplace „Å∏„ÅÆÂÖ¨Èñã
vsce publish
```

## üîÑ **ÁßªË°åÊâãÈ†Ü**

### **Step 1: „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊßãÈÄ†„ÅÆÊ∫ñÂÇô (Day 1-2)**
1. Êñ∞„Åó„ÅÑ„Éá„Ç£„É¨„ÇØ„Éà„É™ `fpga-pin-planner-vscode/` „Çí‰ΩúÊàê
2. VSCodeÊã°Âºµ„ÅÆ„ÉÜ„É≥„Éó„É¨„Éº„Éà„Çí„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
3. ÁèæÂú®„ÅÆReact„Ç¢„Éó„É™„Çí `webview/src/` „Éï„Ç©„É´„ÉÄ„Å´„Ç≥„Éî„Éº
4. `package.json` „ÇíÊã°ÂºµÊ©üËÉΩÁî®„Å´Ë®≠ÂÆö

### **Step 2: Âü∫Êú¨Áµ±Âêà (Day 3-5)**
1. `extension.ts` „Å®„Éë„Éç„É´„ÇØ„É©„Çπ„ÇíÂÆüË£Ö
2. Webview „ÅÆ HTML „ÉÜ„É≥„Éó„É¨„Éº„Éà„Çí‰ΩúÊàê
3. „É°„ÉÉ„Çª„Éº„Ç∏„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†„Çí„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
4. Âü∫Êú¨ÁöÑ„Å™„Ç≥„Éû„É≥„ÉâÂÆüË£Ö

### **Step 3: Ê©üËÉΩÁµ±Âêà (Day 6-10)**
1. „Éï„Ç°„Ç§„É´Êìç‰Ωú„ÅÆ VSCode API Áµ±Âêà
2. Ë®≠ÂÆöÁÆ°ÁêÜ„ÅÆÁßªË°å
3. „Ç≥„Éû„É≥„Éâ„Å®„Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÅÆÂÆüË£Ö
4. „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÅÆÊîπÂñÑ

### **Step 4: È´òÂ∫¶„Å™Ê©üËÉΩ (Day 11-14)**
1. XDCË®ÄË™û„Çµ„Éù„Éº„Éà„ÅÆËøΩÂä†
2. „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éï„Ç°„Ç§„É´ÁÆ°ÁêÜ
3. „Éï„Ç°„Ç§„É´„Ç¶„Ç©„ÉÉ„ÉÅ„É£„Éº„ÅÆÂÆüË£Ö
4. ‰ªñ„ÅÆÊã°ÂºµÊ©üËÉΩ„Å®„ÅÆÈÄ£Êê∫Ê∫ñÂÇô

### **Step 5: „ÉÜ„Çπ„Éà„Å®ÊúÄÈÅ©Âåñ (Day 15-21)**
1. „É≠„Éº„Ç´„É´„Åß„ÅÆÂãï‰ΩúÁ¢∫Ë™ç
2. „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ
3. „Ç¢„Ç§„Ç≥„É≥„Å®„Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà„ÅÆÊ∫ñÂÇô
4. README „Å®„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆ‰ΩúÊàê

### **Step 6: „Éë„ÉÉ„Ç±„Éº„Ç∏„É≥„Ç∞ (Day 22-25)**
1. ÊúÄÁµÇÁöÑ„Å™„Éì„É´„ÉâË®≠ÂÆö
2. Marketplace ÂÖ¨ÈñãÊ∫ñÂÇô
3. „Éô„Éº„Çø„ÉÜ„Çπ„ÉàÂÆüÊñΩ
4. ÂÖ¨Èñã„Å®„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÂèéÈõÜ

## üéØ **ÊúüÂæÖ„Åï„Çå„ÇãÂäπÊûú**

### **ÈñãÁô∫ËÄÖ‰ΩìÈ®ì„ÅÆÂêë‰∏ä**
- Êó¢Â≠ò„ÅÆVSCode„ÉØ„Éº„ÇØ„Éï„É≠„Éº„Å´„Ç∑„Éº„É†„É¨„ÇπÁµ±Âêà
- „Éï„Ç°„Ç§„É´ÁÆ°ÁêÜ„Å®„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈÄ£Êê∫„ÅÆËá™ÂãïÂåñ
- „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Å´„Çà„ÇãÂäπÁéáÁöÑÊìç‰Ωú
- GitÁµ±Âêà„Å´„Çà„ÇãÂ§âÊõ¥Â±•Ê≠¥ÁÆ°ÁêÜ

### **Ê©üËÉΩÊã°Âºµ„ÅÆÂèØËÉΩÊÄß**
- ‰ªñ„ÅÆFPGAÈñ¢ÈÄ£Êã°ÂºµÊ©üËÉΩ„Å®„ÅÆÈÄ£Êê∫
- VSCode „ÅÆË±äÂØå„Å™API„ÅÆÊ¥ªÁî®
- „Éá„Éê„ÉÉ„Ç∞„ÉªË®∫Êñ≠Ê©üËÉΩ„ÅÆÁµ±Âêà
- „ÉÅ„Éº„É†ÈñãÁô∫ÊîØÊè¥Ê©üËÉΩ

### **ÈÖçÂ∏É„Å®„É°„É≥„ÉÜ„Éä„É≥„Çπ**
- Marketplace „Å´„Çà„ÇãÁ∞°Âçò„Ç§„É≥„Çπ„Éà„Éº„É´
- Ëá™ÂãïÊõ¥Êñ∞„Ç∑„Çπ„ÉÜ„É†
- „É¶„Éº„Ç∂„Éº„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÂèéÈõÜ
- „Ç¢„Éä„É™„ÉÜ„Ç£„ÇØ„ÇπÁµ±Âêà

## üìä **ÊäÄË°ìÁöÑËÄÉÊÖÆ‰∫ãÈ†Ö**

### **„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ**
- WebviewÂÜÖ„Åß„ÅÆCanvas„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ
- „É°„É¢„É™‰ΩøÁî®Èáè„ÅÆÁõ£Ë¶ñ„Å®Âà∂Èôê
- Â§ßÈáè„Éî„É≥„Éá„Éº„Çø„ÅÆÂäπÁéáÁöÑÂá¶ÁêÜ
- „É¨„Çπ„Éù„É≥„Ç∑„Éñ„Å™ UI Êõ¥Êñ∞

### **„Çª„Ç≠„É•„É™„ÉÜ„Ç£**
- Content Security Policy „ÅÆÈÅ©Âàá„Å™Ë®≠ÂÆö
- „Éï„Ç°„Ç§„É´„Ç¢„ÇØ„Çª„ÇπÊ®©Èôê„ÅÆÂà∂Èôê
- ÂÖ•Âäõ„Éá„Éº„Çø„ÅÆÊ§úË®º
- Ê©üÂØÜÊÉÖÂ†±„ÅÆ‰øùË≠∑

### **‰∫íÊèõÊÄß**
- VSCode„Éê„Éº„Ç∏„Éß„É≥‰∫íÊèõÊÄß
- „ÇØ„É≠„Çπ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†ÂØæÂøú
- Êó¢Â≠ò„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Å®„ÅÆ‰∫íÊèõÊÄß
- „Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ„Éë„Çπ„ÅÆÊèê‰æõ

## üìö **ÂèÇËÄÉ„É™„ÇΩ„Éº„Çπ**

### **ÂÖ¨Âºè„Éâ„Ç≠„É•„É°„É≥„Éà**
- [VSCode Extension API](https://code.visualstudio.com/api)
- [Webview API Guide](https://code.visualstudio.com/api/extension-guides/webview)
- [Extension Publishing](https://code.visualstudio.com/api/working-with-extensions/publishing-extension)
- [Language Support](https://code.visualstudio.com/api/language-extensions/overview)

### **„Çµ„É≥„Éó„É´„Ç≥„Éº„Éâ**
- [VSCode Extension Samples](https://github.com/microsoft/vscode-extension-samples)
- [Webview Sample](https://github.com/microsoft/vscode-extension-samples/tree/main/webview-sample)
- [Language Server Sample](https://github.com/microsoft/vscode-extension-samples/tree/main/lsp-sample)

### **ÈñãÁô∫„ÉÑ„Éº„É´**
- [Extension Generator](https://code.visualstudio.com/api/get-started/your-first-extension)
- [Extension Test Runner](https://code.visualstudio.com/api/working-with-extensions/testing-extension)
- [Extension Analytics](https://code.visualstudio.com/api/references/extension-manifest#contributes.telemetry)

## üèÅ **„Åæ„Å®„ÇÅ**

„Åì„ÅÆÂÆüË£Ö„Ç¨„Ç§„Éâ„Å´Âæì„ÅÜ„Åì„Å®„Åß„ÄÅÁèæÂú®„ÅÆWeb„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíÂäπÁéáÁöÑ„Å´VSCodeÊã°ÂºµÊ©üËÉΩ„Å®„Åó„Å¶ÁßªË°å„Åß„Åç„Åæ„Åô„ÄÇÊÆµÈöéÁöÑ„Å™„Ç¢„Éó„É≠„Éº„ÉÅ„Å´„Çà„Çä„ÄÅ„É™„Çπ„ÇØ„ÇíÊúÄÂ∞èÈôê„Å´Êäë„Åà„Å™„Åå„Çâ„ÄÅFPGAÈñãÁô∫ËÄÖ„Å´„Å®„Å£„Å¶‰æ°ÂÄ§„ÅÆ„ÅÇ„Çã„ÉÑ„Éº„É´„ÇíÊèê‰æõ„Åß„Åç„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ

VSCodeÊã°ÂºµÊ©üËÉΩ„Å®„Åó„Å¶ÂÆüË£Ö„Åô„Çã„Åì„Å®„Åß„ÄÅFPGAË®≠Ë®àËÄÖ„ÅÆÊó•Â∏∏„ÉØ„Éº„ÇØ„Éï„É≠„Éº„Å´ÂÆåÂÖ®„Å´Áµ±Âêà„Åï„Çå„ÄÅ„Çà„ÇäÂäπÁéáÁöÑ„Åß‰Ωø„ÅÑ„ÇÑ„Åô„ÅÑ„Éî„É≥„Éó„É©„É≥„Éã„É≥„Ç∞‰ΩìÈ®ì„ÇíÊèê‰æõ„Åß„Åç„Åæ„Åô„ÄÇ

---

**‰ΩúÊàêÊó•**: 2025Âπ¥1Êúà31Êó•  
**ÂØæË±°„Éê„Éº„Ç∏„Éß„É≥**: VSCode 1.74.0+  
**ÂÆüË£ÖÊúüÈñì**: Á¥Ñ4ÈÄ±ÈñìÔºà25Êó•ÈñìÔºâ
