// Export service for generating various output formats
import { Pin, Package } from '@/types';
import { getDefaultIOStandard } from '@/constants/pin-constants';

export class ExportService {
  /**
   * Export pins to Xilinx Design Constraints (XDC) format
   */
  static exportToXDC(pins: Pin[], packageData: Package | null): string {
    const assignedPins = pins.filter(pin => pin.isAssigned && pin.signalName.trim() !== '');
    
    const header = [
      `# Xilinx Design Constraints (XDC) File`,
      `# Generated by FPGA Pin Planner`,
      `# Date: ${new Date().toLocaleDateString()}`,
      `# Device: ${packageData?.device || 'Unknown'}`,
      `# Package: ${packageData?.packageType || 'Unknown'}`,
      `#`,
      `# Total pins assigned: ${assignedPins.length}`,
      ``,
    ].join('\n');

    const constraints = assignedPins.map(pin => {
      const lines = [];
      
      // Pin location constraint
      lines.push(`set_property PACKAGE_PIN ${pin.pinNumber} [get_ports ${pin.signalName}]`);
      
      // I/O standard constraint (check user-selected first, then fall back to voltage-based default)
      const userIOStandard = pin.attributes?.['IO_Standard'] || pin.ioType;
      if (userIOStandard && userIOStandard !== 'AUTO') {
        lines.push(`set_property IOSTANDARD ${userIOStandard} [get_ports ${pin.signalName}]`);
      } else if (pin.voltage) {
        const iostandard = getDefaultIOStandard(pin.voltage);
        lines.push(`set_property IOSTANDARD ${iostandard} [get_ports ${pin.signalName}]`);
      }
      
      // Drive strength for outputs (if available and not default)
      const driveStrength = pin.attributes?.['Drive_Strength'];
      if ((pin.direction === 'Output' || pin.direction === 'InOut') && 
          driveStrength && driveStrength !== '---DriveStrength---') {
        lines.push(`set_property DRIVE ${driveStrength} [get_ports ${pin.signalName}]`);
      }
      
      // Slew rate (if specified and not default)
      const slewRate = pin.attributes?.['Slew_Rate'];
      if (slewRate && slewRate !== '---SlewRate---') {
        lines.push(`set_property SLEW ${slewRate} [get_ports ${pin.signalName}]`);
      }
      
      return lines.join('\n');
    }).join('\n\n');

    return header + constraints;
  }

  /**
   * Export pins to Synopsys Design Constraints (SDC) format
   */
  static exportToSDC(pins: Pin[], packageData: Package | null): string {
    const assignedPins = pins.filter(pin => pin.isAssigned && pin.signalName.trim() !== '');
    
    // Signal name sanitization helper
    const sanitizeSignalName = (signalName: string): string => {
      return signalName
        .replace(/[^\w_]/g, '_')    // Replace non-ASCII and special chars with underscore
        .replace(/^(\d)/, 'sig_$1') // Add prefix if starts with number
        .replace(/_{2,}/g, '_')     // Replace multiple underscores with single
        .replace(/^_|_$/g, '');     // Remove leading/trailing underscores
    };
    
    const header = [
      `# Synopsys Design Constraints (SDC) File`,
      `# Generated by FPGA Pin Planner`,
      `# Date: ${new Date().toLocaleDateString()}`,
      `# Device: ${packageData?.device || 'Unknown'}`,
      `# Package: ${packageData?.packageType || 'Unknown'}`,
      `#`,
      `# Total pins assigned: ${assignedPins.length}`,
      ``,
    ].join('\n');

    const constraints = assignedPins.map(pin => {
      const lines = [];
      const sanitizedSignalName = sanitizeSignalName(pin.signalName);
      
      // Pin location constraint (Intel/Altera format)
      lines.push(`set_location_assignment PIN_${pin.pinNumber} -to ${sanitizedSignalName}`);
      
      // I/O standard constraint (if available)
      if (pin.voltage) {
        const iostandard = pin.voltage === '3.3V' ? 'LVCMOS33' : 
                          pin.voltage === '1.8V' ? 'LVCMOS18' :
                          pin.voltage === '2.5V' ? 'LVCMOS25' : 'LVCMOS33';
        lines.push(`set_instance_assignment -name IO_STANDARD "${iostandard}" -to ${sanitizedSignalName}`);
      }
      
      // Drive strength for outputs (if direction is available)
      if (pin.direction === 'Output' || pin.direction === 'InOut') {
        lines.push(`set_instance_assignment -name CURRENT_STRENGTH_NEW "12mA" -to ${sanitizedSignalName}`);
      }
      
      // Slew rate for better signal integrity
      if (pin.direction === 'Output' || pin.direction === 'InOut') {
        lines.push(`set_instance_assignment -name SLEW_RATE 1 -to ${sanitizedSignalName}`);
      }
      
      return lines.join('\n');
    }).join('\n\n');

    return header + constraints;
  }

  /**
   * Export pins to CSV format
   */
  static exportToCSV(pins: Pin[]): string {
    const headers = [
      'Pin Number',
      'Pin Name', 
      'Signal Name',
      'Direction',
      'Pin Type',
      'Voltage',
      'Bank',
      'I/O Type',
      'Is Assigned'
    ];

    const rows = pins.map(pin => [
      pin.pinNumber,
      pin.pinName,
      pin.signalName || '',
      pin.direction,
      pin.pinType,
      pin.voltage,
      pin.bank || '',
      pin.ioType || '',
      pin.isAssigned ? 'Yes' : 'No'
    ]);

    return [headers, ...rows]
      .map(row => row.map(cell => `"${cell}"`).join(','))
      .join('\n');
  }

  /**
   * Export pin assignment report
   */
  static exportReport(pins: Pin[], packageData: Package | null): string {
    const assignedPins = pins.filter(p => p.isAssigned);
    const unassignedPins = pins.filter(p => !p.isAssigned);
    
    const bankStats = new Map<string, {assigned: number, total: number}>();
    pins.forEach(pin => {
      const bank = pin.bank || 'Unknown';
      if (!bankStats.has(bank)) {
        bankStats.set(bank, {assigned: 0, total: 0});
      }
      const stats = bankStats.get(bank)!;
      stats.total++;
      if (pin.isAssigned) stats.assigned++;
    });

    const report = [
      '# FPGA Pin Assignment Report',
      `# Generated: ${new Date().toLocaleString()}`,
      `# Device: ${packageData?.device || 'Unknown'}`,
      `# Package: ${packageData?.packageType || 'Unknown'}`,
      '',
      '## Summary',
      `- Total Pins: ${pins.length}`,
      `- Assigned Pins: ${assignedPins.length}`,
      `- Unassigned Pins: ${unassignedPins.length}`,
      `- Assignment Rate: ${((assignedPins.length / pins.length) * 100).toFixed(1)}%`,
      '',
      '## Bank Statistics',
      ...Array.from(bankStats.entries()).map(([bank, stats]) => 
        `- Bank ${bank}: ${stats.assigned}/${stats.total} (${((stats.assigned/stats.total)*100).toFixed(1)}%)`
      ),
      '',
      '## Assigned Pins',
      ...assignedPins.map(pin => 
        `${pin.pinNumber.padEnd(8)} | ${pin.signalName.padEnd(20)} | Bank ${(pin.bank || 'N/A').padEnd(3)} | ${pin.pinType}`
      ),
      '',
      '## Pin Type Distribution',
      ...Object.entries(
        pins.reduce((acc, pin) => {
          acc[pin.pinType] = (acc[pin.pinType] || 0) + 1;
          return acc;
        }, {} as Record<string, number>)
      ).map(([type, count]) => `- ${type}: ${count}`)
    ];

    return report.join('\n');
  }

  /**
   * Download file helper
   */
  static downloadFile(content: string, filename: string, mimeType: string = 'text/plain') {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}
